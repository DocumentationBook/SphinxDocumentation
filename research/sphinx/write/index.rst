.. _research_sphinx_write:

Resolve and Write
#################

.. graphviz:: phases_write.gv

Sphinx continues processing the parsed documents. It determines the final list of the documents to process and
then implements RESOLVING and WRITING phases for each document.


Process
=======

The main steps are presented on the following diagram:

.. uml:: write.uml
   :alt: The write method

#. Start the ``app.builder.write`` method defined in the ``sphinx.builders.Builder`` class.
   Its signature looks as follows::

       def write(self, build_docnames: Iterable[str], updated_docnames: Sequence[str], \
                  method: str = 'update') -> None:  # NOQA

   If you temporarily uncomment the print statement that follows the method definition, it will display the received
   arguments similar to the following::

      build_docnames: {'folder1/index', 'folder2/index', 'index'}
      updated_docnames: ['folder1/index', 'folder2/index', 'index']
      method: update

   In this list:

   *  ``build_docnames`` is a list of names initially passed to the ``build`` method.
   *  ``updated_docnames`` is a list of names generated by the ``read`` method and extended with the names
      of the outdated documents.
   *  ``method`` defines the operation for the ``app.builder.write`` method.
      If the method is ``update``, the ``app.builder.write`` method will unite ``build_docnames``
      and ``updated_docnames`` into the ``docnames`` set and process the united set.

   The method determines whether to process documents in parallel or sequentially.
   In this process the latter is used.

#. Call the ``app.builder.prepare_writing`` to prepare the documentation.

#. Call the ``app.builder._write_serial`` method passing it the list of documents generated in the previous step.
   The method processes all documents one by one in a cycle.
   To make the method display all files that it processes, add the ``-v`` argument to the ``sphinx-build`` utility.
   Then you will see messages similar to these::

      writing output... [ 33%] folder1/index
      writing output... [ 66%] folder2/index
      writing output... [100%] index

   For each document, the method turns on the RESOLVING phase, in which it runs the ``env.get_and_resolve_doctree``,
   and then the WRITING phase, in which it runs the ``app.builder.write_doc_serialized``
   and ``app.builder.write_doc`` methods.

#. Call the ``app.env.get_and_resolve_doctree`` method passing it the document name and the reference
   to the ``app.builder`` object. This methods orchestrates the document parsing in the following order:

   *  Call the ``app.env.get_doctree`` method passing the document name (docname) to it to find the pickled file
      and read the doctree from it.
   *  Call the ``app.env.apply_post_transforms`` method passing the docname and doctree to it to resolve
      all pending references between the doctree nodes and convert images. To perform those operations, this method
      creates an object from a class extending the ``sphinx.transforms.SphinxTransform`` class and calls
      subsequently its ``add_transforms`` and ``apply_transforms`` methods.
      After processing the doctree, the ``app.env.get_doctree`` method emits the 'doctree-resolved'::

         self.events.emit('doctree-resolved', doctree, docname)

      .. note:: This is where you can handle the 'doctree-resolved' event emitted by the ``app.env.get_doctree`` method.
         A subscribed handler can make changes in the doctree.

   *  Call the ``docutils.nodes.Node.findall`` method to get every doctree node and finally process it
      by creating an object from the ``sphinx.environment.adapters.toctree.TocTree`` class and calling
      its ``resolve`` method.

#. Call the ``app.build.write_doc_serialized`` method passing it the document name and its ``doctree`` determined
   in the previous step. The method performs the following actions:

   *  Call the class-level ``post_process_images`` method of the ``sphinx.builders.Builders`` class to resolve
      URIs of the document images. The method saves the results in the ``app.builder.images`` dictionary.
   *  Call the ``app.builder.index_page``
      to add the document name and title to the ``app.builder.indexer`` object
      of the ``sphinx.search.IndexBuilder`` class.

#. Call the ``app.build.write_doc`` method passing it the document name and its ``doctree`` to finally define all
   document component and save it in its file. The method performs the following operations:

   *  Define the destination as an object of the  ``docutils.io.StringOutput`` class, which is an output wrapper.
      The default destination path in this class is a string::

         default_destination_path = '<string>'

   *  Call the ``app.builder.docwriter.write`` method to perform the document final translation to the specified
      language and to write it using the write method of the ``app.builder.docwriter`` object.
      The latter is an instance of the ``sphinx.writers.html.HTMLWriter`` class which is included in a long
      inheritance chain as presented in :ref:`research_sphinx_write_inheritance`
      The ``write`` method defined in the ``docutils.writers.Writer`` abstract class runs translation
      of the doctree and runs the ``destination.write`` method.
   *  Call the ``app.builder.docwriter.assemble_parts`` method that creates
      the ``app.builder.docwriter.parts`` dictionary.
   *  Call the ``app.builder.get_doc_context`` method to create the template context for the HTML page.
      The method returns the context of the following structure::

         {
            'parents': parents,
            'prev': prev,
            'next': next,
            'title': title,
            'meta': meta,
            'body': body,
            'metatags': metatags,
            'rellinks': rellinks,
            'sourcename': sourcename,
            'toc': toc,
            # only display a TOC if there's more than one item to show
            'display_toc': (self.env.toc_num_entries[docname] > 1),
            'page_source_suffix': source_suffix,
         }

   *  Call the ``app.builder.handle_page`` method to create and save the HTML page.


.. _research_sphinx_write_inheritance:

Class inheritance
=================

In the write steps, the system uses complex class inheritance as displayed on the following diagram:

.. uml:: writer_inheritance.uml
   :alt: Writer inheritance

The ``app.builder.docwriter.write`` method is inherited from the ``docutils.writers.Writer`` abstract class.
To write the doctree, it calls ``destination.write`` method::

         output = self.destination.write(self.output)

The destination object is an instance of the ``docutils.io.StringOutput`` class that defines its ``write`` method as::

   def write(self, data):
      """Encode `data`, store it in `self.destination`, and return it."""
      self.destination = self.encode(data)
      return self.destination


Project state
=============
